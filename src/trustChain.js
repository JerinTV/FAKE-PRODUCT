import { ethers } from "ethers";
import TrustChainAbi from "./TrustChainAbi.json";

/* ================= CONFIG ================= */

// Replace the below with your contract address, or use import.meta.env for Vite, or process.env for CRA at build time
const CONTRACT_ADDRESS = import.meta.env.VITE_CONTRACT_ADDRESS

/* ================= PROVIDER ================= */

const getProvider = () => {
  if (!window.ethereum) throw new Error("MetaMask not found");
  return new ethers.BrowserProvider(window.ethereum);
};

/* ================= CONTRACT ================= */

const getContract = async () => {
  if (!window.ethereum) throw new Error("MetaMask not found");
  await window.ethereum.request({ method: "eth_requestAccounts" });

  const provider = getProvider();
  const signer = await provider.getSigner();

  return new ethers.Contract(CONTRACT_ADDRESS, TrustChainAbi, signer);
};

/* ================= WALLET ================= */

export const connectBlockchain = async () => {
  if (!window.ethereum) throw new Error("MetaMask not found");
  await window.ethereum.request({ method: "eth_requestAccounts" });
  console.log("âœ… Wallet connected");
};

/* ================= BACKEND SECRET STORAGE ================= */



/* ================= SECRET HELPERS ================= */



/* ================= â­ BATCH REGISTER (PRODUCTION) ================= */

export const registerBatch = async (batch) => {
  console.log("ðŸ­ Registering batch:", batch.batchId);

  const contract = await getContract();

  // 1ï¸âƒ£ Ask backend to prepare batch (generate secrets + store in DB)
  const token = localStorage.getItem("token");
  const res = await fetch("http://localhost:5000/prepare-batch", {
    method: "POST",
    headers: { "Content-Type": "application/json",
      "Authorization": `Bearer ${token}`
     },
    body: JSON.stringify(batch)
  });

  if (!res.ok) {
    throw new Error("Failed to prepare batch on backend");
  }

  const { items } = await res.json();

  console.log("ðŸ” Backend prepared secrets & returned items");

  // 2ï¸âƒ£ Single blockchain transaction
  const tx = await contract.registerBatchProducts(
    batch.batchId,
    batch.boxId,
    items
  );

  await tx.wait();

  console.log("âœ… Batch registered on blockchain (ONE TX)");
};


/* ================= SHIP ================= */

export const shipBox = async (boxId) => {
  const contract = await getContract();
  const tx = await contract.shipBox(boxId);
  await tx.wait();
  console.log("ðŸ“¦ Box shipped:", boxId);
};


/* ================= BOX QUERY ================= */

export const getProductIdsByBox = async (boxId) => {
  const contract = await getContract();
  const ids = await contract.getProductsByBox(boxId);
  return ids.map(id => id.toString());
};

/* ================= RETAILER VERIFY ================= */

export const verifyRetailer = async (productId) => {
  const contract = await getContract();
  const tx = await contract.verifyRetailer(productId);
  await tx.wait();
  console.log("âœ… Retailer verified:", productId);
};

/* ================= SALE ================= */

export const saleComplete = async (productId) => {
  const contract = await getContract();
  const tx = await contract.saleComplete(productId);
  await tx.wait();
  console.log("ðŸ’° Sold:", productId);
};

/* ================= FETCH PRODUCT ================= */

export const getProduct = async (productId) => {
  const contract = await getContract();
  const p = await contract.getProduct(productId);

  return {
    productId: p.productId || "",
    boxId: p.boxId || "",
    name: p.name || "",
    category: p.category || "",
    manufacturer: p.manufacturer || "",
    manufacturerDate: p.manufacturerDate || "",
    manufacturePlace: p.manufacturePlace || "",
    modelNumber: p.modelNumber || "",
    serialNumber: p.serialNumber || "",
    warrantyPeriod: p.warrantyPeriod || "",
    batchNumber: p.batchNumber || "",
    color: p.color || "",
    specs: p.specs ? JSON.parse(p.specs) : {},
    price: p.price ? p.price.toString() : "0",
    image: p.image || "",
    shipped: Boolean(p.shipped),
    verifiedByRetailer: Boolean(p.verifiedByRetailer),
    sold: Boolean(p.sold)
  };
};
